"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./store/useStore.ts":
/*!***************************!*\
  !*** ./store/useStore.ts ***!
  \***************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useTaskStore: function() { return /* binding */ useTaskStore; }\n/* harmony export */ });\n/* harmony import */ var zustand__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zustand */ \"(app-pages-browser)/./node_modules/zustand/esm/index.mjs\");\n/* harmony import */ var zustand_middleware__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zustand/middleware */ \"(app-pages-browser)/./node_modules/zustand/esm/middleware.mjs\");\n\n\n// デフォルトラベル\nconst getDefaultLabels = ()=>[\n        {\n            id: \"1\",\n            name: \"本業\",\n            color: \"#2563eb\",\n            createdAt: new Date()\n        },\n        {\n            id: \"2\",\n            name: \"副業\",\n            color: \"#059669\",\n            createdAt: new Date()\n        },\n        {\n            id: \"3\",\n            name: \"プライベート\",\n            color: \"#dc2626\",\n            createdAt: new Date()\n        }\n    ];\nconst useTaskStore = (0,zustand__WEBPACK_IMPORTED_MODULE_0__.create)()((0,zustand_middleware__WEBPACK_IMPORTED_MODULE_1__.persist)((set, get)=>({\n        // Initial state\n        tasks: [],\n        labels: getDefaultLabels(),\n        currentView: \"todo\",\n        selectedLabel: null,\n        filters: {},\n        sortBy: \"dueDate\",\n        sortOrder: \"asc\",\n        // Google Calendar State\n        googleAuthToken: null,\n        googleCalendars: [],\n        googleEvents: [],\n        // Debug State\n        debugHistory: [],\n        maxDebugHistory: 100,\n        // Actions\n        setTasks: (tasks)=>set({\n                tasks\n            }),\n        addTask: (task)=>set((state)=>({\n                    tasks: [\n                        ...state.tasks,\n                        task\n                    ]\n                })),\n        updateTask: (task)=>set((state)=>({\n                    tasks: state.tasks.map((t)=>t.id === task.id ? task : t)\n                })),\n        deleteTask: (taskId)=>set((state)=>({\n                    tasks: state.tasks.filter((t)=>t.id !== taskId)\n                })),\n        setLabels: (labels)=>set({\n                labels\n            }),\n        addLabel: (label)=>set((state)=>({\n                    labels: [\n                        ...state.labels,\n                        label\n                    ]\n                })),\n        updateLabel: (label)=>set((state)=>({\n                    labels: state.labels.map((l)=>l.id === label.id ? label : l)\n                })),\n        deleteLabel: (labelId)=>set((state)=>({\n                    labels: state.labels.filter((l)=>l.id !== labelId),\n                    tasks: state.tasks.map((task)=>task.label === labelId ? {\n                            ...task,\n                            label: \"\"\n                        } : task)\n                })),\n        setCurrentView: (currentView)=>set({\n                currentView\n            }),\n        setSelectedLabel: (selectedLabel)=>set({\n                selectedLabel\n            }),\n        setFilters: (filters)=>set({\n                filters\n            }),\n        setSortBy: (sortBy)=>set({\n                sortBy\n            }),\n        setSortOrder: (sortOrder)=>set({\n                sortOrder\n            }),\n        // Google Calendar Actions\n        setGoogleAuthToken: (token)=>set({\n                googleAuthToken: token\n            }),\n        setGoogleCalendars: (calendars)=>set({\n                googleCalendars: calendars\n            }),\n        setGoogleEvents: (events)=>set({\n                googleEvents: events\n            }),\n        toggleGoogleCalendar: (calendarId)=>set((state)=>({\n                    googleCalendars: state.googleCalendars.map((calendar)=>calendar.id === calendarId ? {\n                            ...calendar,\n                            isSelected: !calendar.isSelected\n                        } : calendar)\n                })),\n        // Debug Actions\n        addDebugInfo: (info)=>set((state)=>{\n                const newDebugInfo = {\n                    ...info,\n                    id: Date.now().toString(),\n                    timestamp: new Date()\n                };\n                const updatedHistory = [\n                    ...state.debugHistory,\n                    newDebugInfo\n                ];\n                // 最大履歴数を超えた場合は古いものから削除\n                if (updatedHistory.length > state.maxDebugHistory) {\n                    updatedHistory.splice(0, updatedHistory.length - state.maxDebugHistory);\n                }\n                return {\n                    debugHistory: updatedHistory\n                };\n            }),\n        clearDebugHistory: ()=>set({\n                debugHistory: []\n            }),\n        setMaxDebugHistory: (max)=>set({\n                maxDebugHistory: max\n            }),\n        // Computed\n        getFilteredTasks: ()=>{\n            const { tasks, filters, selectedLabel } = get();\n            let filtered = tasks;\n            // Label filter\n            if (selectedLabel) {\n                filtered = filtered.filter((task)=>task.label === selectedLabel);\n            }\n            // Status filter\n            if (filters.status) {\n                filtered = filtered.filter((task)=>task.status === filters.status);\n            }\n            // Priority filter\n            if (filters.priority) {\n                filtered = filtered.filter((task)=>task.priority === filters.priority);\n            }\n            // Search filter\n            if (filters.search) {\n                filtered = filtered.filter((task)=>task.title.toLowerCase().includes(filters.search.toLowerCase()) || task.description.toLowerCase().includes(filters.search.toLowerCase()));\n            }\n            return filtered;\n        },\n        getLabelById: (id)=>{\n            const { labels } = get();\n            return labels.find((label)=>label.id === id);\n        }\n    }), {\n    name: \"task-management-storage\",\n    partialize: (state)=>({\n            tasks: state.tasks,\n            labels: state.labels,\n            currentView: state.currentView,\n            filters: state.filters,\n            sortBy: state.sortBy,\n            sortOrder: state.sortOrder,\n            googleAuthToken: state.googleAuthToken,\n            googleCalendars: state.googleCalendars,\n            googleEvents: state.googleEvents,\n            debugHistory: state.debugHistory,\n            maxDebugHistory: state.maxDebugHistory\n        }),\n    onRehydrateStorage: ()=>(state)=>{\n            if (state) {\n                // タスクのみを正しく復元（Googleカレンダーイベントは除外）\n                if (state.tasks && Array.isArray(state.tasks)) {\n                    state.tasks = state.tasks.filter((task)=>task && task.id && task.title && task.status && task.priority !== undefined && task.progress !== undefined && task.startDate && task.dueDate && task.createdAt && task.updatedAt).map((task)=>({\n                            ...task,\n                            startDate: new Date(task.startDate),\n                            dueDate: new Date(task.dueDate),\n                            createdAt: new Date(task.createdAt),\n                            updatedAt: new Date(task.updatedAt)\n                        }));\n                }\n                // ラベルを正しく復元\n                if (state.labels && Array.isArray(state.labels)) {\n                    state.labels = state.labels.map((label)=>({\n                            ...label,\n                            createdAt: new Date(label.createdAt)\n                        }));\n                }\n                // ラベルが空の場合はデフォルトラベルを設定\n                if (!state.labels || state.labels.length === 0) {\n                    state.labels = getDefaultLabels();\n                }\n                // Googleカレンダー関連のデータを初期化（存在しない場合）\n                if (!state.googleAuthToken) state.googleAuthToken = null;\n                if (!state.googleCalendars) state.googleCalendars = [];\n                if (!state.googleEvents) state.googleEvents = [];\n                if (!state.debugHistory) state.debugHistory = [];\n                if (!state.maxDebugHistory) state.maxDebugHistory = 100;\n                // デバッグ履歴のtimestampを正しく復元\n                if (state.debugHistory && Array.isArray(state.debugHistory)) {\n                    state.debugHistory = state.debugHistory.map((debugInfo)=>({\n                            ...debugInfo,\n                            timestamp: new Date(debugInfo.timestamp)\n                        }));\n                }\n            }\n        }\n}));\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q3ZCLElBQUksQ0FBQ29CLE1BQU1kLE1BQU0sSUFBSWMsTUFBTWQsTUFBTSxDQUFDa0QsTUFBTSxLQUFLLEdBQUc7b0JBQzlDcEMsTUFBTWQsTUFBTSxHQUFHVjtnQkFDakI7Z0JBRUEsaUNBQWlDO2dCQUNqQyxJQUFJLENBQUN3QixNQUFNUixlQUFlLEVBQUVRLE1BQU1SLGVBQWUsR0FBRztnQkFDcEQsSUFBSSxDQUFDUSxNQUFNUCxlQUFlLEVBQUVPLE1BQU1QLGVBQWUsR0FBRyxFQUFFO2dCQUN0RCxJQUFJLENBQUNPLE1BQU1OLFlBQVksRUFBRU0sTUFBTU4sWUFBWSxHQUFHLEVBQUU7Z0JBQ2hELElBQUksQ0FBQ00sTUFBTUwsWUFBWSxFQUFFSyxNQUFNTCxZQUFZLEdBQUcsRUFBRTtnQkFDaEQsSUFBSSxDQUFDSyxNQUFNSixlQUFlLEVBQUVJLE1BQU1KLGVBQWUsR0FBRztnQkFFcEQseUJBQXlCO2dCQUN6QixJQUFJSSxNQUFNTCxZQUFZLElBQUkyRCxNQUFNQyxPQUFPLENBQUN2RCxNQUFNTCxZQUFZLEdBQUc7b0JBQzNESyxNQUFNTCxZQUFZLEdBQUdLLE1BQU1MLFlBQVksQ0FBQ08sR0FBRyxDQUFDLENBQUMyRCxZQUFvQjs0QkFDL0QsR0FBR0EsU0FBUzs0QkFDWjNCLFdBQVcsSUFBSXJELEtBQUtnRixVQUFVM0IsU0FBUzt3QkFDekM7Z0JBQ0Y7WUFDRjtRQUNGO0FBQ0YsSUFFRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zdG9yZS91c2VTdG9yZS50cz9lYTMwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZSB9IGZyb20gJ3p1c3RhbmQnO1xuaW1wb3J0IHsgcGVyc2lzdCB9IGZyb20gJ3p1c3RhbmQvbWlkZGxld2FyZSc7XG5pbXBvcnQgeyBUYXNrLCBMYWJlbCwgVGFza0ZpbHRlciwgU29ydE9wdGlvbiB9IGZyb20gJ0AvdHlwZXMnO1xuaW1wb3J0IHsgR29vZ2xlQ2FsZW5kYXIsIEdvb2dsZUNhbGVuZGFyRXZlbnQgfSBmcm9tICdAL2xpYi9nb29nbGVDYWxlbmRhcic7XG5pbXBvcnQgeyBzdG9yYWdlIH0gZnJvbSAnQC9saWIvc3RvcmFnZSc7XG5cbi8vIOODh+ODkOODg+OCsOaDheWgseOBruWei+Wumue+qVxuZXhwb3J0IGludGVyZmFjZSBEZWJ1Z0luZm8ge1xuICBpZDogc3RyaW5nO1xuICB0aW1lc3RhbXA6IERhdGU7XG4gIHR5cGU6ICdnb29nbGVfY2FsZW5kYXInIHwgJ2dhbnR0X2NoYXJ0JyB8ICd0b2RvJyB8ICdnZW5lcmFsJztcbiAgdGl0bGU6IHN0cmluZztcbiAgZGF0YTogYW55O1xuICBzdGF0dXM6ICdzdWNjZXNzJyB8ICdlcnJvcicgfCAnaW5mbycgfCAnd2FybmluZyc7XG59XG5cbmludGVyZmFjZSBUYXNrU3RvcmUge1xuICAvLyBTdGF0ZVxuICB0YXNrczogVGFza1tdO1xuICBsYWJlbHM6IExhYmVsW107XG4gIGN1cnJlbnRWaWV3OiAndG9kbycgfCAnZ2FudHQnIHwgJ2NhbGVuZGFyJyB8ICdzdGF0cycgfCAnc2V0dGluZ3MnIHwgJ2RlYnVnJyB8ICdjb21wbGV0ZWQnO1xuICBzZWxlY3RlZExhYmVsOiBzdHJpbmcgfCBudWxsO1xuICBmaWx0ZXJzOiBUYXNrRmlsdGVyO1xuICBzb3J0Qnk6IFNvcnRPcHRpb247XG4gIHNvcnRPcmRlcjogJ2FzYycgfCAnZGVzYyc7XG4gIFxuICAvLyBHb29nbGUgQ2FsZW5kYXIgU3RhdGVcbiAgZ29vZ2xlQXV0aFRva2VuOiBzdHJpbmcgfCBudWxsO1xuICBnb29nbGVDYWxlbmRhcnM6IEdvb2dsZUNhbGVuZGFyW107XG4gIGdvb2dsZUV2ZW50czogR29vZ2xlQ2FsZW5kYXJFdmVudFtdO1xuXG4gIC8vIERlYnVnIFN0YXRlXG4gIGRlYnVnSGlzdG9yeTogRGVidWdJbmZvW107XG4gIG1heERlYnVnSGlzdG9yeTogbnVtYmVyO1xuXG4gIC8vIEFjdGlvbnNcbiAgc2V0VGFza3M6ICh0YXNrczogVGFza1tdKSA9PiB2b2lkO1xuICBhZGRUYXNrOiAodGFzazogVGFzaykgPT4gdm9pZDtcbiAgdXBkYXRlVGFzazogKHRhc2s6IFRhc2spID0+IHZvaWQ7XG4gIGRlbGV0ZVRhc2s6ICh0YXNrSWQ6IHN0cmluZykgPT4gdm9pZDtcbiAgXG4gIHNldExhYmVsczogKGxhYmVsczogTGFiZWxbXSkgPT4gdm9pZDtcbiAgYWRkTGFiZWw6IChsYWJlbDogTGFiZWwpID0+IHZvaWQ7XG4gIHVwZGF0ZUxhYmVsOiAobGFiZWw6IExhYmVsKSA9PiB2b2lkO1xuICBkZWxldGVMYWJlbDogKGxhYmVsSWQ6IHN0cmluZykgPT4gdm9pZDtcbiAgXG4gIHNldEN1cnJlbnRWaWV3OiAodmlldzogJ3RvZG8nIHwgJ2dhbnR0JyB8ICdjYWxlbmRhcicgfCAnc3RhdHMnIHwgJ3NldHRpbmdzJyB8ICdkZWJ1ZycgfCAnY29tcGxldGVkJykgPT4gdm9pZDtcbiAgc2V0U2VsZWN0ZWRMYWJlbDogKGxhYmVsSWQ6IHN0cmluZyB8IG51bGwpID0+IHZvaWQ7XG4gIHNldEZpbHRlcnM6IChmaWx0ZXJzOiBUYXNrRmlsdGVyKSA9PiB2b2lkO1xuICBzZXRTb3J0Qnk6IChzb3J0Qnk6IFNvcnRPcHRpb24pID0+IHZvaWQ7XG4gIHNldFNvcnRPcmRlcjogKHNvcnRPcmRlcjogJ2FzYycgfCAnZGVzYycpID0+IHZvaWQ7XG4gIFxuICAvLyBHb29nbGUgQ2FsZW5kYXIgQWN0aW9uc1xuICBzZXRHb29nbGVBdXRoVG9rZW46ICh0b2tlbjogc3RyaW5nIHwgbnVsbCkgPT4gdm9pZDtcbiAgc2V0R29vZ2xlQ2FsZW5kYXJzOiAoY2FsZW5kYXJzOiBHb29nbGVDYWxlbmRhcltdKSA9PiB2b2lkO1xuICBzZXRHb29nbGVFdmVudHM6IChldmVudHM6IEdvb2dsZUNhbGVuZGFyRXZlbnRbXSkgPT4gdm9pZDtcbiAgdG9nZ2xlR29vZ2xlQ2FsZW5kYXI6IChjYWxlbmRhcklkOiBzdHJpbmcpID0+IHZvaWQ7XG4gIFxuICAvLyBEZWJ1ZyBBY3Rpb25zXG4gIGFkZERlYnVnSW5mbzogKGluZm86IE9taXQ8RGVidWdJbmZvLCAnaWQnIHwgJ3RpbWVzdGFtcCc+KSA9PiB2b2lkO1xuICBjbGVhckRlYnVnSGlzdG9yeTogKCkgPT4gdm9pZDtcbiAgc2V0TWF4RGVidWdIaXN0b3J5OiAobWF4OiBudW1iZXIpID0+IHZvaWQ7XG4gIFxuICAvLyBDb21wdXRlZFxuICBnZXRGaWx0ZXJlZFRhc2tzOiAoKSA9PiBUYXNrW107XG4gIGdldExhYmVsQnlJZDogKGlkOiBzdHJpbmcpID0+IExhYmVsIHwgdW5kZWZpbmVkO1xufVxuXG4vLyDjg4fjg5Xjgqnjg6vjg4jjg6njg5njg6tcbmNvbnN0IGdldERlZmF1bHRMYWJlbHMgPSAoKTogTGFiZWxbXSA9PiBbXG4gIHtcbiAgICBpZDogJzEnLFxuICAgIG5hbWU6ICfmnKzmpa0nLFxuICAgIGNvbG9yOiAnIzI1NjNlYicsXG4gICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpXG4gIH0sXG4gIHtcbiAgICBpZDogJzInLFxuICAgIG5hbWU6ICflia/mpa0nLFxuICAgIGNvbG9yOiAnIzA1OTY2OScsXG4gICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpXG4gIH0sXG4gIHtcbiAgICBpZDogJzMnLFxuICAgIG5hbWU6ICfjg5fjg6njgqTjg5njg7zjg4gnLFxuICAgIGNvbG9yOiAnI2RjMjYyNicsXG4gICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpXG4gIH1cbl07XG5cbmV4cG9ydCBjb25zdCB1c2VUYXNrU3RvcmUgPSBjcmVhdGU8VGFza1N0b3JlPigpKFxuICBwZXJzaXN0KFxuICAgIChzZXQsIGdldCkgPT4gKHtcbiAgICAgIC8vIEluaXRpYWwgc3RhdGVcbiAgICAgIHRhc2tzOiBbXSxcbiAgICAgIGxhYmVsczogZ2V0RGVmYXVsdExhYmVscygpLFxuICAgICAgY3VycmVudFZpZXc6ICd0b2RvJyxcbiAgICAgIHNlbGVjdGVkTGFiZWw6IG51bGwsXG4gICAgICBmaWx0ZXJzOiB7fSxcbiAgICAgIHNvcnRCeTogJ2R1ZURhdGUnLFxuICAgICAgc29ydE9yZGVyOiAnYXNjJyxcblxuICAgICAgLy8gR29vZ2xlIENhbGVuZGFyIFN0YXRlXG4gICAgICBnb29nbGVBdXRoVG9rZW46IG51bGwsXG4gICAgICBnb29nbGVDYWxlbmRhcnM6IFtdLFxuICAgICAgZ29vZ2xlRXZlbnRzOiBbXSxcblxuICAgICAgLy8gRGVidWcgU3RhdGVcbiAgICAgIGRlYnVnSGlzdG9yeTogW10sXG4gICAgICBtYXhEZWJ1Z0hpc3Rvcnk6IDEwMCxcblxuICAgICAgLy8gQWN0aW9uc1xuICAgICAgc2V0VGFza3M6ICh0YXNrcykgPT4gc2V0KHsgdGFza3MgfSksXG4gICAgICBhZGRUYXNrOiAodGFzaykgPT4gc2V0KChzdGF0ZSkgPT4gKHsgdGFza3M6IFsuLi5zdGF0ZS50YXNrcywgdGFza10gfSkpLFxuICAgICAgdXBkYXRlVGFzazogKHRhc2spID0+IHNldCgoc3RhdGUpID0+ICh7XG4gICAgICAgIHRhc2tzOiBzdGF0ZS50YXNrcy5tYXAodCA9PiB0LmlkID09PSB0YXNrLmlkID8gdGFzayA6IHQpXG4gICAgICB9KSksXG4gICAgICBkZWxldGVUYXNrOiAodGFza0lkKSA9PiBzZXQoKHN0YXRlKSA9PiAoe1xuICAgICAgICB0YXNrczogc3RhdGUudGFza3MuZmlsdGVyKHQgPT4gdC5pZCAhPT0gdGFza0lkKVxuICAgICAgfSkpLFxuXG4gICAgICBzZXRMYWJlbHM6IChsYWJlbHMpID0+IHNldCh7IGxhYmVscyB9KSxcbiAgICAgIGFkZExhYmVsOiAobGFiZWwpID0+IHNldCgoc3RhdGUpID0+ICh7IGxhYmVsczogWy4uLnN0YXRlLmxhYmVscywgbGFiZWxdIH0pKSxcbiAgICAgIHVwZGF0ZUxhYmVsOiAobGFiZWwpID0+IHNldCgoc3RhdGUpID0+ICh7XG4gICAgICAgIGxhYmVsczogc3RhdGUubGFiZWxzLm1hcChsID0+IGwuaWQgPT09IGxhYmVsLmlkID8gbGFiZWwgOiBsKVxuICAgICAgfSkpLFxuICAgICAgZGVsZXRlTGFiZWw6IChsYWJlbElkKSA9PiBzZXQoKHN0YXRlKSA9PiAoe1xuICAgICAgICBsYWJlbHM6IHN0YXRlLmxhYmVscy5maWx0ZXIobCA9PiBsLmlkICE9PSBsYWJlbElkKSxcbiAgICAgICAgdGFza3M6IHN0YXRlLnRhc2tzLm1hcCh0YXNrID0+IFxuICAgICAgICAgIHRhc2subGFiZWwgPT09IGxhYmVsSWQgPyB7IC4uLnRhc2ssIGxhYmVsOiAnJyB9IDogdGFza1xuICAgICAgICApXG4gICAgICB9KSksXG5cbiAgICAgIHNldEN1cnJlbnRWaWV3OiAoY3VycmVudFZpZXcpID0+IHNldCh7IGN1cnJlbnRWaWV3IH0pLFxuICAgICAgc2V0U2VsZWN0ZWRMYWJlbDogKHNlbGVjdGVkTGFiZWwpID0+IHNldCh7IHNlbGVjdGVkTGFiZWwgfSksXG4gICAgICBzZXRGaWx0ZXJzOiAoZmlsdGVycykgPT4gc2V0KHsgZmlsdGVycyB9KSxcbiAgICAgIHNldFNvcnRCeTogKHNvcnRCeSkgPT4gc2V0KHsgc29ydEJ5IH0pLFxuICAgICAgc2V0U29ydE9yZGVyOiAoc29ydE9yZGVyKSA9PiBzZXQoeyBzb3J0T3JkZXIgfSksXG5cbiAgICAgIC8vIEdvb2dsZSBDYWxlbmRhciBBY3Rpb25zXG4gICAgICBzZXRHb29nbGVBdXRoVG9rZW46ICh0b2tlbikgPT4gc2V0KHsgZ29vZ2xlQXV0aFRva2VuOiB0b2tlbiB9KSxcbiAgICAgIHNldEdvb2dsZUNhbGVuZGFyczogKGNhbGVuZGFycykgPT4gc2V0KHsgZ29vZ2xlQ2FsZW5kYXJzOiBjYWxlbmRhcnMgfSksXG4gICAgICBzZXRHb29nbGVFdmVudHM6IChldmVudHMpID0+IHNldCh7IGdvb2dsZUV2ZW50czogZXZlbnRzIH0pLFxuICAgICAgdG9nZ2xlR29vZ2xlQ2FsZW5kYXI6IChjYWxlbmRhcklkKSA9PiBzZXQoKHN0YXRlKSA9PiAoe1xuICAgICAgICBnb29nbGVDYWxlbmRhcnM6IHN0YXRlLmdvb2dsZUNhbGVuZGFycy5tYXAoY2FsZW5kYXIgPT5cbiAgICAgICAgICBjYWxlbmRhci5pZCA9PT0gY2FsZW5kYXJJZCA/IHsgLi4uY2FsZW5kYXIsIGlzU2VsZWN0ZWQ6ICFjYWxlbmRhci5pc1NlbGVjdGVkIH0gOiBjYWxlbmRhclxuICAgICAgICApXG4gICAgICB9KSksXG5cbiAgICAgIC8vIERlYnVnIEFjdGlvbnNcbiAgICAgIGFkZERlYnVnSW5mbzogKGluZm8pID0+IHNldCgoc3RhdGUpID0+IHtcbiAgICAgICAgY29uc3QgbmV3RGVidWdJbmZvID0geyAuLi5pbmZvLCBpZDogRGF0ZS5ub3coKS50b1N0cmluZygpLCB0aW1lc3RhbXA6IG5ldyBEYXRlKCkgfTtcbiAgICAgICAgY29uc3QgdXBkYXRlZEhpc3RvcnkgPSBbLi4uc3RhdGUuZGVidWdIaXN0b3J5LCBuZXdEZWJ1Z0luZm9dO1xuICAgICAgICBcbiAgICAgICAgLy8g5pyA5aSn5bGl5q205pWw44KS6LaF44GI44Gf5aC05ZCI44Gv5Y+k44GE44KC44Gu44GL44KJ5YmK6ZmkXG4gICAgICAgIGlmICh1cGRhdGVkSGlzdG9yeS5sZW5ndGggPiBzdGF0ZS5tYXhEZWJ1Z0hpc3RvcnkpIHtcbiAgICAgICAgICB1cGRhdGVkSGlzdG9yeS5zcGxpY2UoMCwgdXBkYXRlZEhpc3RvcnkubGVuZ3RoIC0gc3RhdGUubWF4RGVidWdIaXN0b3J5KTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHsgZGVidWdIaXN0b3J5OiB1cGRhdGVkSGlzdG9yeSB9O1xuICAgICAgfSksXG4gICAgICBjbGVhckRlYnVnSGlzdG9yeTogKCkgPT4gc2V0KHsgZGVidWdIaXN0b3J5OiBbXSB9KSxcbiAgICAgIHNldE1heERlYnVnSGlzdG9yeTogKG1heCkgPT4gc2V0KHsgbWF4RGVidWdIaXN0b3J5OiBtYXggfSksXG5cbiAgICAgIC8vIENvbXB1dGVkXG4gICAgICBnZXRGaWx0ZXJlZFRhc2tzOiAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgdGFza3MsIGZpbHRlcnMsIHNlbGVjdGVkTGFiZWwgfSA9IGdldCgpO1xuICAgICAgICBsZXQgZmlsdGVyZWQgPSB0YXNrcztcblxuICAgICAgICAvLyBMYWJlbCBmaWx0ZXJcbiAgICAgICAgaWYgKHNlbGVjdGVkTGFiZWwpIHtcbiAgICAgICAgICBmaWx0ZXJlZCA9IGZpbHRlcmVkLmZpbHRlcih0YXNrID0+IHRhc2subGFiZWwgPT09IHNlbGVjdGVkTGFiZWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU3RhdHVzIGZpbHRlclxuICAgICAgICBpZiAoZmlsdGVycy5zdGF0dXMpIHtcbiAgICAgICAgICBmaWx0ZXJlZCA9IGZpbHRlcmVkLmZpbHRlcih0YXNrID0+IHRhc2suc3RhdHVzID09PSBmaWx0ZXJzLnN0YXR1cyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBQcmlvcml0eSBmaWx0ZXJcbiAgICAgICAgaWYgKGZpbHRlcnMucHJpb3JpdHkpIHtcbiAgICAgICAgICBmaWx0ZXJlZCA9IGZpbHRlcmVkLmZpbHRlcih0YXNrID0+IHRhc2sucHJpb3JpdHkgPT09IGZpbHRlcnMucHJpb3JpdHkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2VhcmNoIGZpbHRlclxuICAgICAgICBpZiAoZmlsdGVycy5zZWFyY2gpIHtcbiAgICAgICAgICBmaWx0ZXJlZCA9IGZpbHRlcmVkLmZpbHRlcih0YXNrID0+IFxuICAgICAgICAgICAgdGFzay50aXRsZS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKGZpbHRlcnMuc2VhcmNoIS50b0xvd2VyQ2FzZSgpKSB8fFxuICAgICAgICAgICAgdGFzay5kZXNjcmlwdGlvbi50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKGZpbHRlcnMuc2VhcmNoIS50b0xvd2VyQ2FzZSgpKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmlsdGVyZWQ7XG4gICAgICB9LFxuXG4gICAgICBnZXRMYWJlbEJ5SWQ6IChpZCkgPT4ge1xuICAgICAgICBjb25zdCB7IGxhYmVscyB9ID0gZ2V0KCk7XG4gICAgICAgIHJldHVybiBsYWJlbHMuZmluZChsYWJlbCA9PiBsYWJlbC5pZCA9PT0gaWQpO1xuICAgICAgfSxcbiAgICB9KSxcbiAgICB7XG4gICAgICBuYW1lOiAndGFzay1tYW5hZ2VtZW50LXN0b3JhZ2UnLFxuICAgICAgcGFydGlhbGl6ZTogKHN0YXRlKSA9PiAoe1xuICAgICAgICB0YXNrczogc3RhdGUudGFza3MsXG4gICAgICAgIGxhYmVsczogc3RhdGUubGFiZWxzLFxuICAgICAgICBjdXJyZW50Vmlldzogc3RhdGUuY3VycmVudFZpZXcsXG4gICAgICAgIGZpbHRlcnM6IHN0YXRlLmZpbHRlcnMsXG4gICAgICAgIHNvcnRCeTogc3RhdGUuc29ydEJ5LFxuICAgICAgICBzb3J0T3JkZXI6IHN0YXRlLnNvcnRPcmRlcixcbiAgICAgICAgZ29vZ2xlQXV0aFRva2VuOiBzdGF0ZS5nb29nbGVBdXRoVG9rZW4sXG4gICAgICAgIGdvb2dsZUNhbGVuZGFyczogc3RhdGUuZ29vZ2xlQ2FsZW5kYXJzLFxuICAgICAgICBnb29nbGVFdmVudHM6IHN0YXRlLmdvb2dsZUV2ZW50cyxcbiAgICAgICAgZGVidWdIaXN0b3J5OiBzdGF0ZS5kZWJ1Z0hpc3RvcnksXG4gICAgICAgIG1heERlYnVnSGlzdG9yeTogc3RhdGUubWF4RGVidWdIaXN0b3J5LFxuICAgICAgfSksXG4gICAgICBvblJlaHlkcmF0ZVN0b3JhZ2U6ICgpID0+IChzdGF0ZSkgPT4ge1xuICAgICAgICBpZiAoc3RhdGUpIHtcbiAgICAgICAgICAvLyDjgr/jgrnjgq/jga7jgb/jgpLmraPjgZfjgY/lvqnlhYPvvIhHb29nbGXjgqvjg6zjg7Pjg4Djg7zjgqTjg5njg7Pjg4jjga/pmaTlpJbvvIlcbiAgICAgICAgICBpZiAoc3RhdGUudGFza3MgJiYgQXJyYXkuaXNBcnJheShzdGF0ZS50YXNrcykpIHtcbiAgICAgICAgICAgIHN0YXRlLnRhc2tzID0gc3RhdGUudGFza3NcbiAgICAgICAgICAgICAgLmZpbHRlcigodGFzazogYW55KSA9PiBcbiAgICAgICAgICAgICAgICB0YXNrICYmIFxuICAgICAgICAgICAgICAgIHRhc2suaWQgJiYgXG4gICAgICAgICAgICAgICAgdGFzay50aXRsZSAmJiBcbiAgICAgICAgICAgICAgICB0YXNrLnN0YXR1cyAmJiBcbiAgICAgICAgICAgICAgICB0YXNrLnByaW9yaXR5ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICB0YXNrLnByb2dyZXNzICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICB0YXNrLnN0YXJ0RGF0ZSAmJlxuICAgICAgICAgICAgICAgIHRhc2suZHVlRGF0ZSAmJlxuICAgICAgICAgICAgICAgIHRhc2suY3JlYXRlZEF0ICYmXG4gICAgICAgICAgICAgICAgdGFzay51cGRhdGVkQXRcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAubWFwKCh0YXNrOiBhbnkpID0+ICh7XG4gICAgICAgICAgICAgICAgLi4udGFzayxcbiAgICAgICAgICAgICAgICBzdGFydERhdGU6IG5ldyBEYXRlKHRhc2suc3RhcnREYXRlKSxcbiAgICAgICAgICAgICAgICBkdWVEYXRlOiBuZXcgRGF0ZSh0YXNrLmR1ZURhdGUpLFxuICAgICAgICAgICAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUodGFzay5jcmVhdGVkQXQpLFxuICAgICAgICAgICAgICAgIHVwZGF0ZWRBdDogbmV3IERhdGUodGFzay51cGRhdGVkQXQpXG4gICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8g44Op44OZ44Or44KS5q2j44GX44GP5b6p5YWDXG4gICAgICAgICAgaWYgKHN0YXRlLmxhYmVscyAmJiBBcnJheS5pc0FycmF5KHN0YXRlLmxhYmVscykpIHtcbiAgICAgICAgICAgIHN0YXRlLmxhYmVscyA9IHN0YXRlLmxhYmVscy5tYXAoKGxhYmVsOiBhbnkpID0+ICh7XG4gICAgICAgICAgICAgIC4uLmxhYmVsLFxuICAgICAgICAgICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKGxhYmVsLmNyZWF0ZWRBdClcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyDjg6njg5njg6vjgYznqbrjga7loLTlkIjjga/jg4fjg5Xjgqnjg6vjg4jjg6njg5njg6vjgpLoqK3lrppcbiAgICAgICAgICBpZiAoIXN0YXRlLmxhYmVscyB8fCBzdGF0ZS5sYWJlbHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBzdGF0ZS5sYWJlbHMgPSBnZXREZWZhdWx0TGFiZWxzKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gR29vZ2xl44Kr44Os44Oz44OA44O86Zai6YCj44Gu44OH44O844K/44KS5Yid5pyf5YyW77yI5a2Y5Zyo44GX44Gq44GE5aC05ZCI77yJXG4gICAgICAgICAgaWYgKCFzdGF0ZS5nb29nbGVBdXRoVG9rZW4pIHN0YXRlLmdvb2dsZUF1dGhUb2tlbiA9IG51bGw7XG4gICAgICAgICAgaWYgKCFzdGF0ZS5nb29nbGVDYWxlbmRhcnMpIHN0YXRlLmdvb2dsZUNhbGVuZGFycyA9IFtdO1xuICAgICAgICAgIGlmICghc3RhdGUuZ29vZ2xlRXZlbnRzKSBzdGF0ZS5nb29nbGVFdmVudHMgPSBbXTtcbiAgICAgICAgICBpZiAoIXN0YXRlLmRlYnVnSGlzdG9yeSkgc3RhdGUuZGVidWdIaXN0b3J5ID0gW107XG4gICAgICAgICAgaWYgKCFzdGF0ZS5tYXhEZWJ1Z0hpc3RvcnkpIHN0YXRlLm1heERlYnVnSGlzdG9yeSA9IDEwMDtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyDjg4fjg5Djg4PjgrDlsaXmrbTjga50aW1lc3RhbXDjgpLmraPjgZfjgY/lvqnlhYNcbiAgICAgICAgICBpZiAoc3RhdGUuZGVidWdIaXN0b3J5ICYmIEFycmF5LmlzQXJyYXkoc3RhdGUuZGVidWdIaXN0b3J5KSkge1xuICAgICAgICAgICAgc3RhdGUuZGVidWdIaXN0b3J5ID0gc3RhdGUuZGVidWdIaXN0b3J5Lm1hcCgoZGVidWdJbmZvOiBhbnkpID0+ICh7XG4gICAgICAgICAgICAgIC4uLmRlYnVnSW5mbyxcbiAgICAgICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZShkZWJ1Z0luZm8udGltZXN0YW1wKVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICB9XG4gIClcbik7XG4iXSwibmFtZXMiOlsiY3JlYXRlIiwicGVyc2lzdCIsImdldERlZmF1bHRMYWJlbHMiLCJpZCIsIm5hbWUiLCJjb2xvciIsImNyZWF0ZWRBdCIsIkRhdGUiLCJ1c2VUYXNrU3RvcmUiLCJzZXQiLCJnZXQiLCJ0YXNrcyIsImxhYmVscyIsImN1cnJlbnRWaWV3Iiwic2VsZWN0ZWRMYWJlbCIsImZpbHRlcnMiLCJzb3J0QnkiLCJzb3J0T3JkZXIiLCJnb29nbGVBdXRoVG9rZW4iLCJnb29nbGVDYWxlbmRhcnMiLCJnb29nbGVFdmVudHMiLCJkZWJ1Z0hpc3RvcnkiLCJtYXhEZWJ1Z0hpc3RvcnkiLCJzZXRUYXNrcyIsImFkZFRhc2siLCJ0YXNrIiwic3RhdGUiLCJ1cGRhdGVUYXNrIiwibWFwIiwidCIsImRlbGV0ZVRhc2siLCJ0YXNrSWQiLCJmaWx0ZXIiLCJzZXRMYWJlbHMiLCJhZGRMYWJlbCIsImxhYmVsIiwidXBkYXRlTGFiZWwiLCJsIiwiZGVsZXRlTGFiZWwiLCJsYWJlbElkIiwic2V0Q3VycmVudFZpZXciLCJzZXRTZWxlY3RlZExhYmVsIiwic2V0RmlsdGVycyIsInNldFNvcnRCeSIsInNldFNvcnRPcmRlciIsInNldEdvb2dsZUF1dGhUb2tlbiIsInRva2VuIiwic2V0R29vZ2xlQ2FsZW5kYXJzIiwiY2FsZW5kYXJzIiwic2V0R29vZ2xlRXZlbnRzIiwiZXZlbnRzIiwidG9nZ2xlR29vZ2xlQ2FsZW5kYXIiLCJjYWxlbmRhcklkIiwiY2FsZW5kYXIiLCJpc1NlbGVjdGVkIiwiYWRkRGVidWdJbmZvIiwiaW5mbyIsIm5ld0RlYnVnSW5mbyIsIm5vdyIsInRvU3RyaW5nIiwidGltZXN0YW1wIiwidXBkYXRlZEhpc3RvcnkiLCJsZW5ndGgiLCJzcGxpY2UiLCJjbGVhckRlYnVnSGlzdG9yeSIsInNldE1heERlYnVnSGlzdG9yeSIsIm1heCIsImdldEZpbHRlcmVkVGFza3MiLCJmaWx0ZXJlZCIsInN0YXR1cyIsInByaW9yaXR5Iiwic2VhcmNoIiwidGl0bGUiLCJ0b0xvd2VyQ2FzZSIsImluY2x1ZGVzIiwiZGVzY3JpcHRpb24iLCJnZXRMYWJlbEJ5SWQiLCJmaW5kIiwicGFydGlhbGl6ZSIsIm9uUmVoeWRyYXRlU3RvcmFnZSIsIkFycmF5IiwiaXNBcnJheSIsInVuZGVmaW5lZCIsInByb2dyZXNzIiwic3RhcnREYXRlIiwiZHVlRGF0ZSIsInVwZGF0ZWRBdCIsImRlYnVnSW5mbyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./store/useStore.ts\n"));

/***/ })

});