"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./store/useStore.ts":
/*!***************************!*\
  !*** ./store/useStore.ts ***!
  \***************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useTaskStore: function() { return /* binding */ useTaskStore; }\n/* harmony export */ });\n/* harmony import */ var zustand__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zustand */ \"(app-pages-browser)/./node_modules/zustand/esm/index.mjs\");\n/* harmony import */ var zustand_middleware__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zustand/middleware */ \"(app-pages-browser)/./node_modules/zustand/esm/middleware.mjs\");\n\n\n// デフォルトラベル\nconst getDefaultLabels = ()=>[\n        {\n            id: \"1\",\n            name: \"本業\",\n            color: \"#2563eb\",\n            createdAt: new Date()\n        },\n        {\n            id: \"2\",\n            name: \"副業\",\n            color: \"#059669\",\n            createdAt: new Date()\n        },\n        {\n            id: \"3\",\n            name: \"プライベート\",\n            color: \"#dc2626\",\n            createdAt: new Date()\n        }\n    ];\nconst useTaskStore = (0,zustand__WEBPACK_IMPORTED_MODULE_0__.create)()((0,zustand_middleware__WEBPACK_IMPORTED_MODULE_1__.persist)((set, get)=>({\n        // Initial state\n        tasks: [],\n        labels: getDefaultLabels(),\n        currentView: \"todo\",\n        selectedLabel: null,\n        filters: {},\n        sortBy: \"dueDate\",\n        sortOrder: \"asc\",\n        // Google Calendar State\n        googleAuthToken: null,\n        googleCalendars: [],\n        googleEvents: [],\n        // Debug State\n        debugHistory: [],\n        maxDebugHistory: 100,\n        // Actions\n        setTasks: (tasks)=>set({\n                tasks\n            }),\n        addTask: (task)=>set((state)=>({\n                    tasks: [\n                        ...state.tasks,\n                        task\n                    ]\n                })),\n        updateTask: (task)=>set((state)=>({\n                    tasks: state.tasks.map((t)=>t.id === task.id ? task : t)\n                })),\n        deleteTask: (taskId)=>set((state)=>({\n                    tasks: state.tasks.filter((t)=>t.id !== taskId)\n                })),\n        setLabels: (labels)=>set({\n                labels\n            }),\n        addLabel: (label)=>set((state)=>({\n                    labels: [\n                        ...state.labels,\n                        label\n                    ]\n                })),\n        updateLabel: (label)=>set((state)=>({\n                    labels: state.labels.map((l)=>l.id === label.id ? label : l)\n                })),\n        deleteLabel: (labelId)=>set((state)=>({\n                    labels: state.labels.filter((l)=>l.id !== labelId),\n                    tasks: state.tasks.map((task)=>task.label === labelId ? {\n                            ...task,\n                            label: \"\"\n                        } : task)\n                })),\n        setCurrentView: (currentView)=>set({\n                currentView\n            }),\n        setSelectedLabel: (selectedLabel)=>set({\n                selectedLabel\n            }),\n        setFilters: (filters)=>set({\n                filters\n            }),\n        setSortBy: (sortBy)=>set({\n                sortBy\n            }),\n        setSortOrder: (sortOrder)=>set({\n                sortOrder\n            }),\n        // Google Calendar Actions\n        setGoogleAuthToken: (token)=>set({\n                googleAuthToken: token\n            }),\n        setGoogleCalendars: (calendars)=>set({\n                googleCalendars: calendars\n            }),\n        setGoogleEvents: (events)=>set({\n                googleEvents: events\n            }),\n        toggleGoogleCalendar: (calendarId)=>set((state)=>({\n                    googleCalendars: state.googleCalendars.map((calendar)=>calendar.id === calendarId ? {\n                            ...calendar,\n                            isSelected: !calendar.isSelected\n                        } : calendar)\n                })),\n        // Debug Actions\n        addDebugInfo: (info)=>set((state)=>{\n                const newDebugInfo = {\n                    ...info,\n                    id: Date.now().toString(),\n                    timestamp: new Date()\n                };\n                const updatedHistory = [\n                    ...state.debugHistory,\n                    newDebugInfo\n                ];\n                // 最大履歴数を超えた場合は古いものから削除\n                if (updatedHistory.length > state.maxDebugHistory) {\n                    updatedHistory.splice(0, updatedHistory.length - state.maxDebugHistory);\n                }\n                return {\n                    debugHistory: updatedHistory\n                };\n            }),\n        clearDebugHistory: ()=>set({\n                debugHistory: []\n            }),\n        setMaxDebugHistory: (max)=>set({\n                maxDebugHistory: max\n            }),\n        // Computed\n        getFilteredTasks: ()=>{\n            const { tasks, filters, selectedLabel } = get();\n            let filtered = tasks;\n            // Label filter\n            if (selectedLabel) {\n                filtered = filtered.filter((task)=>task.label === selectedLabel);\n            }\n            // Status filter\n            if (filters.status) {\n                filtered = filtered.filter((task)=>task.status === filters.status);\n            }\n            // Priority filter\n            if (filters.priority) {\n                filtered = filtered.filter((task)=>task.priority === filters.priority);\n            }\n            // Search filter\n            if (filters.search) {\n                filtered = filtered.filter((task)=>task.title.toLowerCase().includes(filters.search.toLowerCase()) || task.description.toLowerCase().includes(filters.search.toLowerCase()));\n            }\n            return filtered;\n        },\n        // 完了タスクを取得\n        getCompletedTasks: ()=>{\n            const { tasks } = get();\n            return tasks.filter((task)=>task.status === \"completed\" && task.completedAt);\n        },\n        // 完了タスクを日付別にグループ化\n        getCompletedTasksByDate: ()=>{\n            const completedTasks = get().getCompletedTasks();\n            const grouped = {};\n            completedTasks.forEach((task)=>{\n                const dateKey = task.completedAt.toISOString().split(\"T\")[0]; // YYYY-MM-DD形式\n                if (!grouped[dateKey]) {\n                    grouped[dateKey] = [];\n                }\n                grouped[dateKey].push(task);\n            });\n            // 日付順にソート（新しい日付が上）\n            return Object.entries(grouped).sort((param, param1)=>{\n                let [a] = param, [b] = param1;\n                return b.localeCompare(a);\n            }).reduce((acc, param)=>{\n                let [date, tasks] = param;\n                acc[date] = tasks.sort((a, b)=>new Date(b.completedAt).getTime() - new Date(a.completedAt).getTime());\n                return acc;\n            }, {});\n        },\n        getLabelById: (id)=>{\n            const { labels } = get();\n            return labels.find((label)=>label.id === id);\n        }\n    }), {\n    name: \"task-management-storage\",\n    partialize: (state)=>({\n            tasks: state.tasks,\n            labels: state.labels,\n            currentView: state.currentView,\n            filters: state.filters,\n            sortBy: state.sortBy,\n            sortOrder: state.sortOrder,\n            googleAuthToken: state.googleAuthToken,\n            googleCalendars: state.googleCalendars,\n            googleEvents: state.googleEvents,\n            debugHistory: state.debugHistory,\n            maxDebugHistory: state.maxDebugHistory\n        }),\n    onRehydrateStorage: ()=>(state)=>{\n            if (state) {\n                // タスクのみを正しく復元（Googleカレンダーイベントは除外）\n                if (state.tasks && Array.isArray(state.tasks)) {\n                    state.tasks = state.tasks.filter((task)=>task && task.id && task.title && task.status && task.priority !== undefined && task.progress !== undefined && task.startDate && task.dueDate && task.createdAt && task.updatedAt).map((task)=>({\n                            ...task,\n                            startDate: new Date(task.startDate),\n                            dueDate: new Date(task.dueDate),\n                            createdAt: new Date(task.createdAt),\n                            updatedAt: new Date(task.updatedAt)\n                        }));\n                }\n                // ラベルを正しく復元\n                if (state.labels && Array.isArray(state.labels)) {\n                    state.labels = state.labels.map((label)=>({\n                            ...label,\n                            createdAt: new Date(label.createdAt)\n                        }));\n                }\n                // ラベルが空の場合はデフォルトラベルを設定\n                if (!state.labels || state.labels.length === 0) {\n                    state.labels = getDefaultLabels();\n                }\n                // Googleカレンダー関連のデータを初期化（存在しない場合）\n                if (!state.googleAuthToken) state.googleAuthToken = null;\n                if (!state.googleCalendars) state.googleCalendars = [];\n                if (!state.googleEvents) state.googleEvents = [];\n                if (!state.debugHistory) state.debugHistory = [];\n                if (!state.maxDebugHistory) state.maxDebugHistory = 100;\n                // デバッグ履歴のtimestampを正しく復元\n                if (state.debugHistory && Array.isArray(state.debugHistory)) {\n                    state.debugHistory = state.debugHistory.map((debugInfo)=>({\n                            ...debugInfo,\n                            timestamp: new Date(debugInfo.timestamp)\n                        }));\n                }\n            }\n        }\n}));\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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R1Y7Z0JBQ2pCO2dCQUVBLGlDQUFpQztnQkFDakMsSUFBSSxDQUFDd0IsTUFBTVIsZUFBZSxFQUFFUSxNQUFNUixlQUFlLEdBQUc7Z0JBQ3BELElBQUksQ0FBQ1EsTUFBTVAsZUFBZSxFQUFFTyxNQUFNUCxlQUFlLEdBQUcsRUFBRTtnQkFDdEQsSUFBSSxDQUFDTyxNQUFNTixZQUFZLEVBQUVNLE1BQU1OLFlBQVksR0FBRyxFQUFFO2dCQUNoRCxJQUFJLENBQUNNLE1BQU1MLFlBQVksRUFBRUssTUFBTUwsWUFBWSxHQUFHLEVBQUU7Z0JBQ2hELElBQUksQ0FBQ0ssTUFBTUosZUFBZSxFQUFFSSxNQUFNSixlQUFlLEdBQUc7Z0JBRXBELHlCQUF5QjtnQkFDekIsSUFBSUksTUFBTUwsWUFBWSxJQUFJK0UsTUFBTUMsT0FBTyxDQUFDM0UsTUFBTUwsWUFBWSxHQUFHO29CQUMzREssTUFBTUwsWUFBWSxHQUFHSyxNQUFNTCxZQUFZLENBQUNPLEdBQUcsQ0FBQyxDQUFDK0UsWUFBb0I7NEJBQy9ELEdBQUdBLFNBQVM7NEJBQ1ovQyxXQUFXLElBQUlyRCxLQUFLb0csVUFBVS9DLFNBQVM7d0JBQ3pDO2dCQUNGO1lBQ0Y7UUFDRjtBQUNGLElBRUYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3RvcmUvdXNlU3RvcmUudHM/ZWEzMCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGUgfSBmcm9tICd6dXN0YW5kJztcbmltcG9ydCB7IHBlcnNpc3QgfSBmcm9tICd6dXN0YW5kL21pZGRsZXdhcmUnO1xuaW1wb3J0IHsgVGFzaywgTGFiZWwsIFRhc2tGaWx0ZXIsIFNvcnRPcHRpb24gfSBmcm9tICdAL3R5cGVzJztcbmltcG9ydCB7IEdvb2dsZUNhbGVuZGFyLCBHb29nbGVDYWxlbmRhckV2ZW50IH0gZnJvbSAnQC9saWIvZ29vZ2xlQ2FsZW5kYXInO1xuaW1wb3J0IHsgc3RvcmFnZSB9IGZyb20gJ0AvbGliL3N0b3JhZ2UnO1xuXG4vLyDjg4fjg5Djg4PjgrDmg4XloLHjga7lnovlrprnvqlcbmV4cG9ydCBpbnRlcmZhY2UgRGVidWdJbmZvIHtcbiAgaWQ6IHN0cmluZztcbiAgdGltZXN0YW1wOiBEYXRlO1xuICB0eXBlOiAnZ29vZ2xlX2NhbGVuZGFyJyB8ICdnYW50dF9jaGFydCcgfCAndG9kbycgfCAnZ2VuZXJhbCc7XG4gIHRpdGxlOiBzdHJpbmc7XG4gIGRhdGE6IGFueTtcbiAgc3RhdHVzOiAnc3VjY2VzcycgfCAnZXJyb3InIHwgJ2luZm8nIHwgJ3dhcm5pbmcnO1xufVxuXG5pbnRlcmZhY2UgVGFza1N0b3JlIHtcbiAgLy8gU3RhdGVcbiAgdGFza3M6IFRhc2tbXTtcbiAgbGFiZWxzOiBMYWJlbFtdO1xuICBjdXJyZW50VmlldzogJ3RvZG8nIHwgJ2dhbnR0JyB8ICdjYWxlbmRhcicgfCAnc3RhdHMnIHwgJ3NldHRpbmdzJyB8ICdkZWJ1ZycgfCAnY29tcGxldGVkJztcbiAgc2VsZWN0ZWRMYWJlbDogc3RyaW5nIHwgbnVsbDtcbiAgZmlsdGVyczogVGFza0ZpbHRlcjtcbiAgc29ydEJ5OiBTb3J0T3B0aW9uO1xuICBzb3J0T3JkZXI6ICdhc2MnIHwgJ2Rlc2MnO1xuICBcbiAgLy8gR29vZ2xlIENhbGVuZGFyIFN0YXRlXG4gIGdvb2dsZUF1dGhUb2tlbjogc3RyaW5nIHwgbnVsbDtcbiAgZ29vZ2xlQ2FsZW5kYXJzOiBHb29nbGVDYWxlbmRhcltdO1xuICBnb29nbGVFdmVudHM6IEdvb2dsZUNhbGVuZGFyRXZlbnRbXTtcblxuICAvLyBEZWJ1ZyBTdGF0ZVxuICBkZWJ1Z0hpc3Rvcnk6IERlYnVnSW5mb1tdO1xuICBtYXhEZWJ1Z0hpc3Rvcnk6IG51bWJlcjtcblxuICAvLyBBY3Rpb25zXG4gIHNldFRhc2tzOiAodGFza3M6IFRhc2tbXSkgPT4gdm9pZDtcbiAgYWRkVGFzazogKHRhc2s6IFRhc2spID0+IHZvaWQ7XG4gIHVwZGF0ZVRhc2s6ICh0YXNrOiBUYXNrKSA9PiB2b2lkO1xuICBkZWxldGVUYXNrOiAodGFza0lkOiBzdHJpbmcpID0+IHZvaWQ7XG4gIFxuICBzZXRMYWJlbHM6IChsYWJlbHM6IExhYmVsW10pID0+IHZvaWQ7XG4gIGFkZExhYmVsOiAobGFiZWw6IExhYmVsKSA9PiB2b2lkO1xuICB1cGRhdGVMYWJlbDogKGxhYmVsOiBMYWJlbCkgPT4gdm9pZDtcbiAgZGVsZXRlTGFiZWw6IChsYWJlbElkOiBzdHJpbmcpID0+IHZvaWQ7XG4gIFxuICBzZXRDdXJyZW50VmlldzogKHZpZXc6ICd0b2RvJyB8ICdnYW50dCcgfCAnY2FsZW5kYXInIHwgJ3N0YXRzJyB8ICdzZXR0aW5ncycgfCAnZGVidWcnIHwgJ2NvbXBsZXRlZCcpID0+IHZvaWQ7XG4gIHNldFNlbGVjdGVkTGFiZWw6IChsYWJlbElkOiBzdHJpbmcgfCBudWxsKSA9PiB2b2lkO1xuICBzZXRGaWx0ZXJzOiAoZmlsdGVyczogVGFza0ZpbHRlcikgPT4gdm9pZDtcbiAgc2V0U29ydEJ5OiAoc29ydEJ5OiBTb3J0T3B0aW9uKSA9PiB2b2lkO1xuICBzZXRTb3J0T3JkZXI6IChzb3J0T3JkZXI6ICdhc2MnIHwgJ2Rlc2MnKSA9PiB2b2lkO1xuICBcbiAgLy8gR29vZ2xlIENhbGVuZGFyIEFjdGlvbnNcbiAgc2V0R29vZ2xlQXV0aFRva2VuOiAodG9rZW46IHN0cmluZyB8IG51bGwpID0+IHZvaWQ7XG4gIHNldEdvb2dsZUNhbGVuZGFyczogKGNhbGVuZGFyczogR29vZ2xlQ2FsZW5kYXJbXSkgPT4gdm9pZDtcbiAgc2V0R29vZ2xlRXZlbnRzOiAoZXZlbnRzOiBHb29nbGVDYWxlbmRhckV2ZW50W10pID0+IHZvaWQ7XG4gIHRvZ2dsZUdvb2dsZUNhbGVuZGFyOiAoY2FsZW5kYXJJZDogc3RyaW5nKSA9PiB2b2lkO1xuICBcbiAgLy8gRGVidWcgQWN0aW9uc1xuICBhZGREZWJ1Z0luZm86IChpbmZvOiBPbWl0PERlYnVnSW5mbywgJ2lkJyB8ICd0aW1lc3RhbXAnPikgPT4gdm9pZDtcbiAgY2xlYXJEZWJ1Z0hpc3Rvcnk6ICgpID0+IHZvaWQ7XG4gIHNldE1heERlYnVnSGlzdG9yeTogKG1heDogbnVtYmVyKSA9PiB2b2lkO1xuICBcbiAgLy8gQ29tcHV0ZWRcbiAgZ2V0RmlsdGVyZWRUYXNrczogKCkgPT4gVGFza1tdO1xuICBnZXRMYWJlbEJ5SWQ6IChpZDogc3RyaW5nKSA9PiBMYWJlbCB8IHVuZGVmaW5lZDtcbn1cblxuLy8g44OH44OV44Kp44Or44OI44Op44OZ44OrXG5jb25zdCBnZXREZWZhdWx0TGFiZWxzID0gKCk6IExhYmVsW10gPT4gW1xuICB7XG4gICAgaWQ6ICcxJyxcbiAgICBuYW1lOiAn5pys5qWtJyxcbiAgICBjb2xvcjogJyMyNTYzZWInLFxuICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKVxuICB9LFxuICB7XG4gICAgaWQ6ICcyJyxcbiAgICBuYW1lOiAn5Ymv5qWtJyxcbiAgICBjb2xvcjogJyMwNTk2NjknLFxuICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKVxuICB9LFxuICB7XG4gICAgaWQ6ICczJyxcbiAgICBuYW1lOiAn44OX44Op44Kk44OZ44O844OIJyxcbiAgICBjb2xvcjogJyNkYzI2MjYnLFxuICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKVxuICB9XG5dO1xuXG5leHBvcnQgY29uc3QgdXNlVGFza1N0b3JlID0gY3JlYXRlPFRhc2tTdG9yZT4oKShcbiAgcGVyc2lzdChcbiAgICAoc2V0LCBnZXQpID0+ICh7XG4gICAgICAvLyBJbml0aWFsIHN0YXRlXG4gICAgICB0YXNrczogW10sXG4gICAgICBsYWJlbHM6IGdldERlZmF1bHRMYWJlbHMoKSxcbiAgICAgIGN1cnJlbnRWaWV3OiAndG9kbycsXG4gICAgICBzZWxlY3RlZExhYmVsOiBudWxsLFxuICAgICAgZmlsdGVyczoge30sXG4gICAgICBzb3J0Qnk6ICdkdWVEYXRlJyxcbiAgICAgIHNvcnRPcmRlcjogJ2FzYycsXG5cbiAgICAgIC8vIEdvb2dsZSBDYWxlbmRhciBTdGF0ZVxuICAgICAgZ29vZ2xlQXV0aFRva2VuOiBudWxsLFxuICAgICAgZ29vZ2xlQ2FsZW5kYXJzOiBbXSxcbiAgICAgIGdvb2dsZUV2ZW50czogW10sXG5cbiAgICAgIC8vIERlYnVnIFN0YXRlXG4gICAgICBkZWJ1Z0hpc3Rvcnk6IFtdLFxuICAgICAgbWF4RGVidWdIaXN0b3J5OiAxMDAsXG5cbiAgICAgIC8vIEFjdGlvbnNcbiAgICAgIHNldFRhc2tzOiAodGFza3MpID0+IHNldCh7IHRhc2tzIH0pLFxuICAgICAgYWRkVGFzazogKHRhc2spID0+IHNldCgoc3RhdGUpID0+ICh7IHRhc2tzOiBbLi4uc3RhdGUudGFza3MsIHRhc2tdIH0pKSxcbiAgICAgIHVwZGF0ZVRhc2s6ICh0YXNrKSA9PiBzZXQoKHN0YXRlKSA9PiAoe1xuICAgICAgICB0YXNrczogc3RhdGUudGFza3MubWFwKHQgPT4gdC5pZCA9PT0gdGFzay5pZCA/IHRhc2sgOiB0KVxuICAgICAgfSkpLFxuICAgICAgZGVsZXRlVGFzazogKHRhc2tJZCkgPT4gc2V0KChzdGF0ZSkgPT4gKHtcbiAgICAgICAgdGFza3M6IHN0YXRlLnRhc2tzLmZpbHRlcih0ID0+IHQuaWQgIT09IHRhc2tJZClcbiAgICAgIH0pKSxcblxuICAgICAgc2V0TGFiZWxzOiAobGFiZWxzKSA9PiBzZXQoeyBsYWJlbHMgfSksXG4gICAgICBhZGRMYWJlbDogKGxhYmVsKSA9PiBzZXQoKHN0YXRlKSA9PiAoeyBsYWJlbHM6IFsuLi5zdGF0ZS5sYWJlbHMsIGxhYmVsXSB9KSksXG4gICAgICB1cGRhdGVMYWJlbDogKGxhYmVsKSA9PiBzZXQoKHN0YXRlKSA9PiAoe1xuICAgICAgICBsYWJlbHM6IHN0YXRlLmxhYmVscy5tYXAobCA9PiBsLmlkID09PSBsYWJlbC5pZCA/IGxhYmVsIDogbClcbiAgICAgIH0pKSxcbiAgICAgIGRlbGV0ZUxhYmVsOiAobGFiZWxJZCkgPT4gc2V0KChzdGF0ZSkgPT4gKHtcbiAgICAgICAgbGFiZWxzOiBzdGF0ZS5sYWJlbHMuZmlsdGVyKGwgPT4gbC5pZCAhPT0gbGFiZWxJZCksXG4gICAgICAgIHRhc2tzOiBzdGF0ZS50YXNrcy5tYXAodGFzayA9PiBcbiAgICAgICAgICB0YXNrLmxhYmVsID09PSBsYWJlbElkID8geyAuLi50YXNrLCBsYWJlbDogJycgfSA6IHRhc2tcbiAgICAgICAgKVxuICAgICAgfSkpLFxuXG4gICAgICBzZXRDdXJyZW50VmlldzogKGN1cnJlbnRWaWV3KSA9PiBzZXQoeyBjdXJyZW50VmlldyB9KSxcbiAgICAgIHNldFNlbGVjdGVkTGFiZWw6IChzZWxlY3RlZExhYmVsKSA9PiBzZXQoeyBzZWxlY3RlZExhYmVsIH0pLFxuICAgICAgc2V0RmlsdGVyczogKGZpbHRlcnMpID0+IHNldCh7IGZpbHRlcnMgfSksXG4gICAgICBzZXRTb3J0Qnk6IChzb3J0QnkpID0+IHNldCh7IHNvcnRCeSB9KSxcbiAgICAgIHNldFNvcnRPcmRlcjogKHNvcnRPcmRlcikgPT4gc2V0KHsgc29ydE9yZGVyIH0pLFxuXG4gICAgICAvLyBHb29nbGUgQ2FsZW5kYXIgQWN0aW9uc1xuICAgICAgc2V0R29vZ2xlQXV0aFRva2VuOiAodG9rZW4pID0+IHNldCh7IGdvb2dsZUF1dGhUb2tlbjogdG9rZW4gfSksXG4gICAgICBzZXRHb29nbGVDYWxlbmRhcnM6IChjYWxlbmRhcnMpID0+IHNldCh7IGdvb2dsZUNhbGVuZGFyczogY2FsZW5kYXJzIH0pLFxuICAgICAgc2V0R29vZ2xlRXZlbnRzOiAoZXZlbnRzKSA9PiBzZXQoeyBnb29nbGVFdmVudHM6IGV2ZW50cyB9KSxcbiAgICAgIHRvZ2dsZUdvb2dsZUNhbGVuZGFyOiAoY2FsZW5kYXJJZCkgPT4gc2V0KChzdGF0ZSkgPT4gKHtcbiAgICAgICAgZ29vZ2xlQ2FsZW5kYXJzOiBzdGF0ZS5nb29nbGVDYWxlbmRhcnMubWFwKGNhbGVuZGFyID0+XG4gICAgICAgICAgY2FsZW5kYXIuaWQgPT09IGNhbGVuZGFySWQgPyB7IC4uLmNhbGVuZGFyLCBpc1NlbGVjdGVkOiAhY2FsZW5kYXIuaXNTZWxlY3RlZCB9IDogY2FsZW5kYXJcbiAgICAgICAgKVxuICAgICAgfSkpLFxuXG4gICAgICAvLyBEZWJ1ZyBBY3Rpb25zXG4gICAgICBhZGREZWJ1Z0luZm86IChpbmZvKSA9PiBzZXQoKHN0YXRlKSA9PiB7XG4gICAgICAgIGNvbnN0IG5ld0RlYnVnSW5mbyA9IHsgLi4uaW5mbywgaWQ6IERhdGUubm93KCkudG9TdHJpbmcoKSwgdGltZXN0YW1wOiBuZXcgRGF0ZSgpIH07XG4gICAgICAgIGNvbnN0IHVwZGF0ZWRIaXN0b3J5ID0gWy4uLnN0YXRlLmRlYnVnSGlzdG9yeSwgbmV3RGVidWdJbmZvXTtcbiAgICAgICAgXG4gICAgICAgIC8vIOacgOWkp+WxpeattOaVsOOCkui2heOBiOOBn+WgtOWQiOOBr+WPpOOBhOOCguOBruOBi+OCieWJiumZpFxuICAgICAgICBpZiAodXBkYXRlZEhpc3RvcnkubGVuZ3RoID4gc3RhdGUubWF4RGVidWdIaXN0b3J5KSB7XG4gICAgICAgICAgdXBkYXRlZEhpc3Rvcnkuc3BsaWNlKDAsIHVwZGF0ZWRIaXN0b3J5Lmxlbmd0aCAtIHN0YXRlLm1heERlYnVnSGlzdG9yeSk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiB7IGRlYnVnSGlzdG9yeTogdXBkYXRlZEhpc3RvcnkgfTtcbiAgICAgIH0pLFxuICAgICAgY2xlYXJEZWJ1Z0hpc3Rvcnk6ICgpID0+IHNldCh7IGRlYnVnSGlzdG9yeTogW10gfSksXG4gICAgICBzZXRNYXhEZWJ1Z0hpc3Rvcnk6IChtYXgpID0+IHNldCh7IG1heERlYnVnSGlzdG9yeTogbWF4IH0pLFxuXG4gICAgICAvLyBDb21wdXRlZFxuICAgICAgZ2V0RmlsdGVyZWRUYXNrczogKCkgPT4ge1xuICAgICAgICBjb25zdCB7IHRhc2tzLCBmaWx0ZXJzLCBzZWxlY3RlZExhYmVsIH0gPSBnZXQoKTtcbiAgICAgICAgbGV0IGZpbHRlcmVkID0gdGFza3M7XG5cbiAgICAgICAgLy8gTGFiZWwgZmlsdGVyXG4gICAgICAgIGlmIChzZWxlY3RlZExhYmVsKSB7XG4gICAgICAgICAgZmlsdGVyZWQgPSBmaWx0ZXJlZC5maWx0ZXIodGFzayA9PiB0YXNrLmxhYmVsID09PSBzZWxlY3RlZExhYmVsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFN0YXR1cyBmaWx0ZXJcbiAgICAgICAgaWYgKGZpbHRlcnMuc3RhdHVzKSB7XG4gICAgICAgICAgZmlsdGVyZWQgPSBmaWx0ZXJlZC5maWx0ZXIodGFzayA9PiB0YXNrLnN0YXR1cyA9PT0gZmlsdGVycy5zdGF0dXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUHJpb3JpdHkgZmlsdGVyXG4gICAgICAgIGlmIChmaWx0ZXJzLnByaW9yaXR5KSB7XG4gICAgICAgICAgZmlsdGVyZWQgPSBmaWx0ZXJlZC5maWx0ZXIodGFzayA9PiB0YXNrLnByaW9yaXR5ID09PSBmaWx0ZXJzLnByaW9yaXR5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNlYXJjaCBmaWx0ZXJcbiAgICAgICAgaWYgKGZpbHRlcnMuc2VhcmNoKSB7XG4gICAgICAgICAgZmlsdGVyZWQgPSBmaWx0ZXJlZC5maWx0ZXIodGFzayA9PiBcbiAgICAgICAgICAgIHRhc2sudGl0bGUudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhmaWx0ZXJzLnNlYXJjaCEudG9Mb3dlckNhc2UoKSkgfHxcbiAgICAgICAgICAgIHRhc2suZGVzY3JpcHRpb24udG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhmaWx0ZXJzLnNlYXJjaCEudG9Mb3dlckNhc2UoKSlcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZpbHRlcmVkO1xuICAgICAgfSxcblxuICAgICAgLy8g5a6M5LqG44K/44K544Kv44KS5Y+W5b6XXG4gICAgICBnZXRDb21wbGV0ZWRUYXNrczogKCkgPT4ge1xuICAgICAgICBjb25zdCB7IHRhc2tzIH0gPSBnZXQoKTtcbiAgICAgICAgcmV0dXJuIHRhc2tzLmZpbHRlcih0YXNrID0+IHRhc2suc3RhdHVzID09PSAnY29tcGxldGVkJyAmJiB0YXNrLmNvbXBsZXRlZEF0KTtcbiAgICAgIH0sXG5cbiAgICAgIC8vIOWujOS6huOCv+OCueOCr+OCkuaXpeS7mOWIpeOBq+OCsOODq+ODvOODl+WMllxuICAgICAgZ2V0Q29tcGxldGVkVGFza3NCeURhdGU6ICgpID0+IHtcbiAgICAgICAgY29uc3QgY29tcGxldGVkVGFza3MgPSBnZXQoKS5nZXRDb21wbGV0ZWRUYXNrcygpO1xuICAgICAgICBjb25zdCBncm91cGVkOiB7IFtrZXk6IHN0cmluZ106IFRhc2tbXSB9ID0ge307XG5cbiAgICAgICAgY29tcGxldGVkVGFza3MuZm9yRWFjaCh0YXNrID0+IHtcbiAgICAgICAgICBjb25zdCBkYXRlS2V5ID0gdGFzay5jb21wbGV0ZWRBdCEudG9JU09TdHJpbmcoKS5zcGxpdCgnVCcpWzBdOyAvLyBZWVlZLU1NLURE5b2i5byPXG4gICAgICAgICAgaWYgKCFncm91cGVkW2RhdGVLZXldKSB7XG4gICAgICAgICAgICBncm91cGVkW2RhdGVLZXldID0gW107XG4gICAgICAgICAgfVxuICAgICAgICAgIGdyb3VwZWRbZGF0ZUtleV0ucHVzaCh0YXNrKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8g5pel5LuY6aCG44Gr44K944O844OI77yI5paw44GX44GE5pel5LuY44GM5LiK77yJXG4gICAgICAgIHJldHVybiBPYmplY3QuZW50cmllcyhncm91cGVkKVxuICAgICAgICAgIC5zb3J0KChbYV0sIFtiXSkgPT4gYi5sb2NhbGVDb21wYXJlKGEpKVxuICAgICAgICAgIC5yZWR1Y2UoKGFjYywgW2RhdGUsIHRhc2tzXSkgPT4ge1xuICAgICAgICAgICAgYWNjW2RhdGVdID0gdGFza3Muc29ydCgoYSwgYikgPT4gXG4gICAgICAgICAgICAgIG5ldyBEYXRlKGIuY29tcGxldGVkQXQhKS5nZXRUaW1lKCkgLSBuZXcgRGF0ZShhLmNvbXBsZXRlZEF0ISkuZ2V0VGltZSgpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgICB9LCB7fSBhcyB7IFtrZXk6IHN0cmluZ106IFRhc2tbXSB9KTtcbiAgICAgIH0sXG5cbiAgICAgIGdldExhYmVsQnlJZDogKGlkKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgbGFiZWxzIH0gPSBnZXQoKTtcbiAgICAgICAgcmV0dXJuIGxhYmVscy5maW5kKGxhYmVsID0+IGxhYmVsLmlkID09PSBpZCk7XG4gICAgICB9LFxuICAgIH0pLFxuICAgIHtcbiAgICAgIG5hbWU6ICd0YXNrLW1hbmFnZW1lbnQtc3RvcmFnZScsXG4gICAgICBwYXJ0aWFsaXplOiAoc3RhdGUpID0+ICh7XG4gICAgICAgIHRhc2tzOiBzdGF0ZS50YXNrcyxcbiAgICAgICAgbGFiZWxzOiBzdGF0ZS5sYWJlbHMsXG4gICAgICAgIGN1cnJlbnRWaWV3OiBzdGF0ZS5jdXJyZW50VmlldyxcbiAgICAgICAgZmlsdGVyczogc3RhdGUuZmlsdGVycyxcbiAgICAgICAgc29ydEJ5OiBzdGF0ZS5zb3J0QnksXG4gICAgICAgIHNvcnRPcmRlcjogc3RhdGUuc29ydE9yZGVyLFxuICAgICAgICBnb29nbGVBdXRoVG9rZW46IHN0YXRlLmdvb2dsZUF1dGhUb2tlbixcbiAgICAgICAgZ29vZ2xlQ2FsZW5kYXJzOiBzdGF0ZS5nb29nbGVDYWxlbmRhcnMsXG4gICAgICAgIGdvb2dsZUV2ZW50czogc3RhdGUuZ29vZ2xlRXZlbnRzLFxuICAgICAgICBkZWJ1Z0hpc3Rvcnk6IHN0YXRlLmRlYnVnSGlzdG9yeSxcbiAgICAgICAgbWF4RGVidWdIaXN0b3J5OiBzdGF0ZS5tYXhEZWJ1Z0hpc3RvcnksXG4gICAgICB9KSxcbiAgICAgIG9uUmVoeWRyYXRlU3RvcmFnZTogKCkgPT4gKHN0YXRlKSA9PiB7XG4gICAgICAgIGlmIChzdGF0ZSkge1xuICAgICAgICAgIC8vIOOCv+OCueOCr+OBruOBv+OCkuato+OBl+OBj+W+qeWFg++8iEdvb2dsZeOCq+ODrOODs+ODgOODvOOCpOODmeODs+ODiOOBr+mZpOWklu+8iVxuICAgICAgICAgIGlmIChzdGF0ZS50YXNrcyAmJiBBcnJheS5pc0FycmF5KHN0YXRlLnRhc2tzKSkge1xuICAgICAgICAgICAgc3RhdGUudGFza3MgPSBzdGF0ZS50YXNrc1xuICAgICAgICAgICAgICAuZmlsdGVyKCh0YXNrOiBhbnkpID0+IFxuICAgICAgICAgICAgICAgIHRhc2sgJiYgXG4gICAgICAgICAgICAgICAgdGFzay5pZCAmJiBcbiAgICAgICAgICAgICAgICB0YXNrLnRpdGxlICYmIFxuICAgICAgICAgICAgICAgIHRhc2suc3RhdHVzICYmIFxuICAgICAgICAgICAgICAgIHRhc2sucHJpb3JpdHkgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgIHRhc2sucHJvZ3Jlc3MgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgIHRhc2suc3RhcnREYXRlICYmXG4gICAgICAgICAgICAgICAgdGFzay5kdWVEYXRlICYmXG4gICAgICAgICAgICAgICAgdGFzay5jcmVhdGVkQXQgJiZcbiAgICAgICAgICAgICAgICB0YXNrLnVwZGF0ZWRBdFxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIC5tYXAoKHRhc2s6IGFueSkgPT4gKHtcbiAgICAgICAgICAgICAgICAuLi50YXNrLFxuICAgICAgICAgICAgICAgIHN0YXJ0RGF0ZTogbmV3IERhdGUodGFzay5zdGFydERhdGUpLFxuICAgICAgICAgICAgICAgIGR1ZURhdGU6IG5ldyBEYXRlKHRhc2suZHVlRGF0ZSksXG4gICAgICAgICAgICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSh0YXNrLmNyZWF0ZWRBdCksXG4gICAgICAgICAgICAgICAgdXBkYXRlZEF0OiBuZXcgRGF0ZSh0YXNrLnVwZGF0ZWRBdClcbiAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyDjg6njg5njg6vjgpLmraPjgZfjgY/lvqnlhYNcbiAgICAgICAgICBpZiAoc3RhdGUubGFiZWxzICYmIEFycmF5LmlzQXJyYXkoc3RhdGUubGFiZWxzKSkge1xuICAgICAgICAgICAgc3RhdGUubGFiZWxzID0gc3RhdGUubGFiZWxzLm1hcCgobGFiZWw6IGFueSkgPT4gKHtcbiAgICAgICAgICAgICAgLi4ubGFiZWwsXG4gICAgICAgICAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUobGFiZWwuY3JlYXRlZEF0KVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIOODqeODmeODq+OBjOepuuOBruWgtOWQiOOBr+ODh+ODleOCqeODq+ODiOODqeODmeODq+OCkuioreWumlxuICAgICAgICAgIGlmICghc3RhdGUubGFiZWxzIHx8IHN0YXRlLmxhYmVscy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHN0YXRlLmxhYmVscyA9IGdldERlZmF1bHRMYWJlbHMoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBHb29nbGXjgqvjg6zjg7Pjg4Djg7zplqLpgKPjga7jg4fjg7zjgr/jgpLliJ3mnJ/ljJbvvIjlrZjlnKjjgZfjgarjgYTloLTlkIjvvIlcbiAgICAgICAgICBpZiAoIXN0YXRlLmdvb2dsZUF1dGhUb2tlbikgc3RhdGUuZ29vZ2xlQXV0aFRva2VuID0gbnVsbDtcbiAgICAgICAgICBpZiAoIXN0YXRlLmdvb2dsZUNhbGVuZGFycykgc3RhdGUuZ29vZ2xlQ2FsZW5kYXJzID0gW107XG4gICAgICAgICAgaWYgKCFzdGF0ZS5nb29nbGVFdmVudHMpIHN0YXRlLmdvb2dsZUV2ZW50cyA9IFtdO1xuICAgICAgICAgIGlmICghc3RhdGUuZGVidWdIaXN0b3J5KSBzdGF0ZS5kZWJ1Z0hpc3RvcnkgPSBbXTtcbiAgICAgICAgICBpZiAoIXN0YXRlLm1heERlYnVnSGlzdG9yeSkgc3RhdGUubWF4RGVidWdIaXN0b3J5ID0gMTAwO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIOODh+ODkOODg+OCsOWxpeattOOBrnRpbWVzdGFtcOOCkuato+OBl+OBj+W+qeWFg1xuICAgICAgICAgIGlmIChzdGF0ZS5kZWJ1Z0hpc3RvcnkgJiYgQXJyYXkuaXNBcnJheShzdGF0ZS5kZWJ1Z0hpc3RvcnkpKSB7XG4gICAgICAgICAgICBzdGF0ZS5kZWJ1Z0hpc3RvcnkgPSBzdGF0ZS5kZWJ1Z0hpc3RvcnkubWFwKChkZWJ1Z0luZm86IGFueSkgPT4gKHtcbiAgICAgICAgICAgICAgLi4uZGVidWdJbmZvLFxuICAgICAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKGRlYnVnSW5mby50aW1lc3RhbXApXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgIH1cbiAgKVxuKTtcbiJdLCJuYW1lcyI6WyJjcmVhdGUiLCJwZXJzaXN0IiwiZ2V0RGVmYXVsdExhYmVscyIsImlkIiwibmFtZSIsImNvbG9yIiwiY3JlYXRlZEF0IiwiRGF0ZSIsInVzZVRhc2tTdG9yZSIsInNldCIsImdldCIsInRhc2tzIiwibGFiZWxzIiwiY3VycmVudFZpZXciLCJzZWxlY3RlZExhYmVsIiwiZmlsdGVycyIsInNvcnRCeSIsInNvcnRPcmRlciIsImdvb2dsZUF1dGhUb2tlbiIsImdvb2dsZUNhbGVuZGFycyIsImdvb2dsZUV2ZW50cyIsImRlYnVnSGlzdG9yeSIsIm1heERlYnVnSGlzdG9yeSIsInNldFRhc2tzIiwiYWRkVGFzayIsInRhc2siLCJzdGF0ZSIsInVwZGF0ZVRhc2siLCJtYXAiLCJ0IiwiZGVsZXRlVGFzayIsInRhc2tJZCIsImZpbHRlciIsInNldExhYmVscyIsImFkZExhYmVsIiwibGFiZWwiLCJ1cGRhdGVMYWJlbCIsImwiLCJkZWxldGVMYWJlbCIsImxhYmVsSWQiLCJzZXRDdXJyZW50VmlldyIsInNldFNlbGVjdGVkTGFiZWwiLCJzZXRGaWx0ZXJzIiwic2V0U29ydEJ5Iiwic2V0U29ydE9yZGVyIiwic2V0R29vZ2xlQXV0aFRva2VuIiwidG9rZW4iLCJzZXRHb29nbGVDYWxlbmRhcnMiLCJjYWxlbmRhcnMiLCJzZXRHb29nbGVFdmVudHMiLCJldmVudHMiLCJ0b2dnbGVHb29nbGVDYWxlbmRhciIsImNhbGVuZGFySWQiLCJjYWxlbmRhciIsImlzU2VsZWN0ZWQiLCJhZGREZWJ1Z0luZm8iLCJpbmZvIiwibmV3RGVidWdJbmZvIiwibm93IiwidG9TdHJpbmciLCJ0aW1lc3RhbXAiLCJ1cGRhdGVkSGlzdG9yeSIsImxlbmd0aCIsInNwbGljZSIsImNsZWFyRGVidWdIaXN0b3J5Iiwic2V0TWF4RGVidWdIaXN0b3J5IiwibWF4IiwiZ2V0RmlsdGVyZWRUYXNrcyIsImZpbHRlcmVkIiwic3RhdHVzIiwicHJpb3JpdHkiLCJzZWFyY2giLCJ0aXRsZSIsInRvTG93ZXJDYXNlIiwiaW5jbHVkZXMiLCJkZXNjcmlwdGlvbiIsImdldENvbXBsZXRlZFRhc2tzIiwiY29tcGxldGVkQXQiLCJnZXRDb21wbGV0ZWRUYXNrc0J5RGF0ZSIsImNvbXBsZXRlZFRhc2tzIiwiZ3JvdXBlZCIsImZvckVhY2giLCJkYXRlS2V5IiwidG9JU09TdHJpbmciLCJzcGxpdCIsInB1c2giLCJPYmplY3QiLCJlbnRyaWVzIiwic29ydCIsImEiLCJiIiwibG9jYWxlQ29tcGFyZSIsInJlZHVjZSIsImFjYyIsImRhdGUiLCJnZXRUaW1lIiwiZ2V0TGFiZWxCeUlkIiwiZmluZCIsInBhcnRpYWxpemUiLCJvblJlaHlkcmF0ZVN0b3JhZ2UiLCJBcnJheSIsImlzQXJyYXkiLCJ1bmRlZmluZWQiLCJwcm9ncmVzcyIsInN0YXJ0RGF0ZSIsImR1ZURhdGUiLCJ1cGRhdGVkQXQiLCJkZWJ1Z0luZm8iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./store/useStore.ts\n"));

/***/ })

});